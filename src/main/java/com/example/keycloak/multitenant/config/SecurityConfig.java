package com.example.keycloak.multitenant.config;import com.example.keycloak.multitenant.security.KeycloakAuthenticationProvider;import java.util.Collections;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.HttpMethod;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.authentication.ProviderManager;import org.springframework.security.authentication.dao.DaoAuthenticationProvider;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.web.SecurityFilterChain;import org.springframework.security.web.context.HttpSessionSecurityContextRepository;import org.springframework.security.web.context.SecurityContextRepository;import org.springframework.web.client.RestTemplate;/** * Configuración principal de seguridad para una aplicación multi-tenant con Keycloak. * Esta clase configura la seguridad de Spring Security para integrar la autenticación * con Keycloak en un entorno de microservicio REST. Se centra en un flujo de login * manual (Password Grant Type) y está diseñada para un único realm de Keycloak con * múltiples clientes. */@Configuration@EnableWebSecuritypublic class SecurityConfig {    private static final Logger log = LoggerFactory.getLogger(SecurityConfig.class);    /**     * Contraseña dummy utilizada para el {@link UserDetailsService} y el {@link PasswordEncoder}     * en el flujo de login manual.     */    public static final String DUMMY_PASSWORD = "dummy_password";    /**     * Constructor     */    public SecurityConfig() {    }    /**     * Configura la cadena de filtros de seguridad HTTP para la aplicación.     * Define las reglas de autorización para diferentes rutas, desactiva CSRF,     * y gestiona el logout y las políticas de sesión.     *     * @param http El objeto {@link HttpSecurity} para configurar la seguridad web.     * @return Un {@link SecurityFilterChain} configurado que define el comportamiento de seguridad.     * @throws Exception Si ocurre un error durante la configuración de seguridad.     */    @Bean    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {        log.info("Configurando SecurityFilterChain para el microservicio REST.");        http                .csrf(AbstractHttpConfigurer::disable)                .httpBasic(AbstractHttpConfigurer::disable)                .formLogin(AbstractHttpConfigurer::disable)                .logout(AbstractHttpConfigurer::disable)                .authorizeHttpRequests(authorize -> authorize                        .requestMatchers(                                "/",                                "/public/**",                                "/error",                                "/api/*/swagger-ui/**",                                "/api/*/v3/api-docs/**",                                "/api/*/openapi/openapi.yaml",                                "/api/*/webjars/**"                        ).permitAll()                        .requestMatchers(HttpMethod.GET, "/api/*/*/login", "/api/*/*/users").permitAll()                        .requestMatchers(HttpMethod.POST, "/api/*/*/users/register").permitAll()                        .requestMatchers(HttpMethod.POST, "/api/*/admin/token").permitAll()                        .requestMatchers(HttpMethod.PUT, "/api/*/*/users/**").permitAll()                        .requestMatchers(HttpMethod.DELETE, "/api/*/*/users/**").permitAll()                        .requestMatchers(HttpMethod.POST, "/api/*/*/{client}/do_login", "/api/*/refresh", "/api/*/logout").permitAll()                        .requestMatchers(HttpMethod.POST, "/api/*/*/roles").permitAll()                        .requestMatchers(HttpMethod.DELETE, "/api/*/*/roles/{roleName}").permitAll()                        .requestMatchers(HttpMethod.GET, "/api/*/*/roles").permitAll()                        .anyRequest().authenticated()                )                .sessionManagement(session -> session                        .sessionFixation().migrateSession()                        .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)                        .maximumSessions(1)                        .maxSessionsPreventsLogin(false)                );        log.info("SecurityFilterChain configurado.");        return http.build();    }    /**     * Define un {@link AuthenticationManager} que es responsable de procesar los intentos de autenticación.     * En este caso, utiliza un {@link ProviderManager} con un único {@link KeycloakAuthenticationProvider}     * que delega la autenticación real a Keycloak.     *     * @param keycloakAuthenticationProvider El proveedor de autenticación personalizado que interactúa con Keycloak.     * @return Una instancia de {@link AuthenticationManager} configurada.     */    @Bean    public AuthenticationManager authenticationManager(KeycloakAuthenticationProvider keycloakAuthenticationProvider) {        log.debug("Configurando AuthenticationManager con KeycloakAuthenticationProvider.");        return new ProviderManager(Collections.singletonList(keycloakAuthenticationProvider));    }    /**     * Un {@link UserDetailsService} "dummy" o de solo marcador de posición.     * <p>     * Este servicio no realiza una verificación real de usuario/contraseña.     * Su propósito es satisfacer la dependencia de {@link DaoAuthenticationProvider},     * que forma parte del proceso de Spring Security para autenticar y cargar detalles de usuario.     * La contraseña devuelta ({@link #DUMMY_PASSWORD}) es simplemente un valor para     * evitar que el {@code DaoAuthenticationProvider} falle en su paso de comparación de contraseñas.     * Los roles y otros detalles del usuario se obtienen de Keycloak y se adjuntan     * al {@link org.springframework.security.core.Authentication} en el controlador de login     * después de que Keycloak ha autenticado exitosamente al usuario.     * </p>     *     * @return Una instancia de {@link UserDetailsService} que devuelve un usuario con una contraseña dummy.     */    @Bean    public UserDetailsService userDetailsService() {        log.debug("Configurando UserDetailsService dummy.");        return username -> {            // La contraseña debe coincidir con DUMMY_PASSWORD para que el DaoAuthenticationProvider no falle.            return User.withUsername(username)                    .password(DUMMY_PASSWORD) // Contraseña dummy, solo para satisfacer la verificación del provider.                    .authorities(Collections.emptyList()) // Los roles reales se establecerán en el AuthenticationToken en LoginController.                    .build();        };    }    /**     * Define un {@link SecurityContextRepository} para gestionar cómo se guarda     * y recupera el {@link org.springframework.security.core.context.SecurityContext}     * en la {@link jakarta.servlet.http.HttpSession}. Esto es fundamental para     * mantener el estado de autenticación del usuario entre diferentes peticiones     * HTTP cuando se utilizan sesiones.     *     * @return Una instancia de {@link HttpSessionSecurityContextRepository}.     */    @Bean    public SecurityContextRepository securityContextRepository() {        log.debug("Configurando SecurityContextRepository.");        return new HttpSessionSecurityContextRepository();    }    /**     * Define un bean de {@link RestTemplate}.     * Este bean es crucial para que otras partes de la aplicación (como {@code LoginController})     * puedan realizar llamadas HTTP síncronas a Keycloak. Por ejemplo, se utiliza para     * intercambiar credenciales por tokens OAuth2/OIDC con el servidor de autenticación.     *     * @return Una instancia configurada de {@link RestTemplate}.     */    @Bean    public RestTemplate restTemplate() {        log.debug("Configurando RestTemplate.");        return new RestTemplate();    }}