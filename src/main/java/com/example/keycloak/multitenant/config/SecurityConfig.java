package com.example.keycloak.multitenant.config;import com.example.keycloak.multitenant.security.KeycloakAuthenticationProvider;import java.util.Collections;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.HttpMethod;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.authentication.ProviderManager;import org.springframework.security.authentication.dao.DaoAuthenticationProvider;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.web.SecurityFilterChain;import org.springframework.security.web.context.HttpSessionSecurityContextRepository;import org.springframework.security.web.context.SecurityContextRepository;import org.springframework.web.client.RestTemplate;/** * Configuración principal de seguridad para una aplicación multi-tenant con Keycloak. * <p> * Esta clase configura la seguridad de Spring Security para integrar la autenticación * con Keycloak en un entorno de microservicio REST. Se centra en un flujo de login * manual (Password Grant Type) y está diseñada para un único realm de Keycloak con * múltiples clientes. * * @author Angel Fm * @version 1.0 */@Configuration@EnableWebSecuritypublic class SecurityConfig {    private static final Logger log = LoggerFactory.getLogger(SecurityConfig.class);    /**     * Contraseña dummy utilizada para el {@link UserDetailsService} y el {@link PasswordEncoder}     * en el flujo de login manual.     */    public static final String DUMMY_PASSWORD = "dummy_password";    private static final String[] PUBLIC_ENDPOINTS = {            "/",            "/public/**",            "/error",            "/api/*/swagger-ui/**",            "/api/*/v3/api-docs/**",            "/api/*/openapi/openapi.yaml",            "/api/*/webjars/**"    };    private static final String[] PUBLIC_GET_ENDPOINTS = {            "/api/*/*/login",            "/api/*/*/users",            "/api/*/*/users/attributes",            "/api/*/*/users/email/{email}",            "/api/*/*/users/{userId}",            "/api/*/*/roles",            "/api/*/*/roles/{roleName}/attributes",            "/api/{realm}/password/verify",            "/{realm}/password/verify",            "/*/{client}/login",            "/*/{client}/register"    };    private static final String[] PUBLIC_POST_ENDPOINTS = {            "/api/*/*/auth/{client}/validate",            "/api/*/*/auth/{client}/token",            "/api/*/*/users/register",            "/api/*/*/users/{userId}/password-reset",            "/api/*/*/{client}/users/{userId}/change-password",            "/api/*/*/{client}/do_login",            "/api/*/refresh",            "/api/*/logout",            "/api/*/*/roles",            "/api/*/clients/create",            "/api/*/realms/create",            "/api/{realm}/password/set",            "/{realm}/password/set",            "/*/{client}/do_login",            "/*/{client}/register",    };    private static final String[] PUBLIC_PUT_ENDPOINTS = {            "/api/*/*/users/**",            "/api/*/*/roles/{roleName}/attributes"    };    private static final String[] PUBLIC_DELETE_ENDPOINTS = {            "/api/*/*/users/**",            "/api/*/*/roles/{roleName}",            "/api/*/*/roles/{roleName}/attributes/{attributeName}"    };    /**     * Constructor     */    public SecurityConfig() {        log.info("Inicializando la clase de configuración de seguridad.");    }    /**     * Configura la cadena de filtros de seguridad HTTP para la aplicación.     * <p>     * Define las reglas de autorización para diferentes rutas, desactiva CSRF,     * y gestiona el logout y las políticas de sesión.     *     * @param http El objeto {@link HttpSecurity} para configurar la seguridad web.     * @return Un {@link SecurityFilterChain} configurado que define el comportamiento de seguridad.     * @throws Exception Si ocurre un error durante la configuración de seguridad.     */    @Bean    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {        log.info("Configurando SecurityFilterChain para el microservicio REST.");        http                .csrf(AbstractHttpConfigurer::disable)                .httpBasic(AbstractHttpConfigurer::disable)                .formLogin(AbstractHttpConfigurer::disable)                .logout(AbstractHttpConfigurer::disable)                .authorizeHttpRequests(authorize -> authorize                        .requestMatchers(PUBLIC_ENDPOINTS).permitAll()                        .requestMatchers(HttpMethod.GET, PUBLIC_GET_ENDPOINTS).permitAll()                        .requestMatchers(HttpMethod.POST, PUBLIC_POST_ENDPOINTS).permitAll()                        .requestMatchers(HttpMethod.PUT, PUBLIC_PUT_ENDPOINTS).permitAll()                        .requestMatchers(HttpMethod.DELETE, PUBLIC_DELETE_ENDPOINTS).permitAll()                        .anyRequest().authenticated()                )                .sessionManagement(session -> session                        .sessionFixation().migrateSession()                        .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)                        .maximumSessions(1)                        .maxSessionsPreventsLogin(false)                )                .exceptionHandling(ex -> ex                        // 401 si no está autenticado                        .authenticationEntryPoint((req, res, e) -> {                            log.warn("401 Unauthorized: {}", e.getMessage());                            res.setStatus(401);                        })                        // 403 si no tiene permisos                        .accessDeniedHandler((req, res, e) -> {                            log.warn("403 Forbidden: {}", e.getMessage());                            res.setStatus(403);                        })                );        log.info("SecurityFilterChain configurado.");        return http.build();    }    /**     * Define un {@link AuthenticationManager} que es responsable de procesar los intentos de autenticación.     * <p>     * En este caso, utiliza un {@link ProviderManager} con un único {@link KeycloakAuthenticationProvider}     * que delega la autenticación real a Keycloak.     *     * @param keycloakAuthenticationProvider El proveedor de autenticación personalizado que interactúa con Keycloak.     * @return Una instancia de {@link AuthenticationManager} configurada.     */    @Bean    public AuthenticationManager authenticationManager(KeycloakAuthenticationProvider keycloakAuthenticationProvider) {        log.debug("Configurando AuthenticationManager con KeycloakAuthenticationProvider.");        return new ProviderManager(Collections.singletonList(keycloakAuthenticationProvider));    }    /**     * Un {@link UserDetailsService} "dummy" o de solo marcador de posición.     * <p>     * Este servicio no realiza una verificación real de usuario/contraseña.     * Su propósito es satisfacer la dependencia de {@link DaoAuthenticationProvider},     * que forma parte del proceso de Spring Security para autenticar y cargar detalles de usuario.     * La contraseña devuelta ({@link #DUMMY_PASSWORD}) es simplemente un valor para     * evitar que el {@code DaoAuthenticationProvider} falle en su paso de comparación de contraseñas.     * Los roles y otros detalles del usuario se obtienen de Keycloak y se adjuntan     * al {@link org.springframework.security.core.Authentication} en el controlador de login     * después de que Keycloak ha autenticado exitosamente al usuario.     *     * @return Una instancia de {@link UserDetailsService} que devuelve un usuario con una contraseña dummy.     */    @Bean    public UserDetailsService userDetailsService() {        log.debug("Configurando UserDetailsService dummy.");        return username -> {            // La contraseña debe coincidir con DUMMY_PASSWORD para que el DaoAuthenticationProvider no falle.            return User.withUsername(username)                    .password(DUMMY_PASSWORD) // Contraseña dummy, solo para satisfacer la verificación del provider.                    .authorities(Collections.emptyList()) // Los roles reales se establecerán en el AuthenticationToken en LoginController.                    .build();        };    }    /**     * Define un {@link SecurityContextRepository} para gestionar cómo se guarda     * y recupera el {@link org.springframework.security.core.context.SecurityContext}     * en la {@link jakarta.servlet.http.HttpSession}. Esto es fundamental para     * mantener el estado de autenticación del usuario entre diferentes peticiones     * HTTP cuando se utilizan sesiones.     *     * @return Una instancia de {@link HttpSessionSecurityContextRepository}.     */    @Bean    public SecurityContextRepository securityContextRepository() {        log.debug("Configurando SecurityContextRepository.");        return new HttpSessionSecurityContextRepository();    }    /**     * Define un bean de {@link RestTemplate}.     * <p>     * Este bean es crucial para que otras partes de la aplicación (como los servicios de Keycloak)     * puedan realizar llamadas HTTP síncronas a Keycloak. Por ejemplo, se utiliza para     * intercambiar credenciales por tokens OAuth2/OIDC con el servidor de autenticación.     *     * @return Una instancia configurada de {@link RestTemplate}.     */    @Bean    public RestTemplate restTemplate() {        log.debug("Configurando RestTemplate.");        return new RestTemplate();    }}